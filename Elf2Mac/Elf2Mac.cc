/*
     Copyright 2017 Wolfgang Thaller.

     This file is part of Retro68.

     Retro68 is free software: you can redistribute it and/or modify
     it under the terms of the GNU General Public License as published by
     the Free Software Foundation, either version 3 of the License, or
     (at your option) any later version.

     Retro68 is distributed in the hope that it will be useful,
     but WITHOUT ANY WARRANTY; without even the implied warranty of
     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     GNU General Public License for more details.

     You should have received a copy of the GNU General Public License
     along with Retro68.  If not, see <http://www.gnu.org/licenses/>.
*/

/**
 * Elf2Mac converts a normal elf-m68k executable to a Mac or Palm OS resource
 * file. It can be used either as a wrapper around binutils ld or as a
 * standalone utility. It works by generating a linker script for GNU ld, then
 * invoking ld, then performing post-processing on the intermediate elf-m68k
 * binary generated by ld and writing the processed data to the final output
 * resource file.
 *
 * The linker script is responsible for:
 *
 * • Splitting the `.text` section into multiple code sections according to the
 *   user-provided segment map (see SegmentMap);
 * • Merging ELF code and data sections into fewer sections suitable for
 *   resource files;
 * • Adding symbols for the libretro runtime to do relocation;
 * • Fixing relocation offsets by setting section VMAs and inserting required
 *   section headers that will be filled in later by Elf2Mac;
 * • Inserting the entrypoint trampoline for the code 1 resource.
 *
 * Elf2Mac is responsible for:
 *
 * • Transforming ELF relocations to libretro/Palm OS format;
 * • Replacing cross-section function calls with calls to the jump table to
 *   support on-demand code loading on Mac OS;
 * • Building the jump table and writing it to the appropriate place;
 * • Compressing section data (for Palm OS);
 * • Filling in code resource headers.
 *
 * Refer to Inside Macintosh “Mac OS Runtime Architectures” for details on the
 * Mac OS runtime environment and Apple’s linker architecture. Details on the
 * Palm OS runtime environment are largely derived from reverse-engineering and
 * prc-tools since public documentation was either never provided or lost behind
 * an unarchived login wall.
 */

#include "Object.h"
#include "SegmentMap.h"

#include <algorithm>
#include <cstring>
#include <filesystem>
#include <fstream>
#include <iostream>
#include <string>
#include <system_error>
#include <vector>

#include <unistd.h>
#include <sys/types.h>
#include <sys/wait.h>

using namespace std::literals::string_literals;

static int RealLD(const std::vector<const char *> &argv)
{
    pid_t pid = fork();
    if(pid < 0)
        throw std::runtime_error("unable to fork: "s + strerror(errno));
    else if(pid == 0)
    {
        execvp(argv[0], const_cast<char* const *> (argv.data()));
        throw std::runtime_error("exec failed: "s + strerror(errno));
    }

    int wstatus;
    int result = 0;
    do
    {
        result = waitpid(pid, &wstatus, 0);
    } while(result == -1 && errno == EINTR);

    if(!WIFEXITED(wstatus))
        throw std::runtime_error("ld process did not exit properly");

    return WEXITSTATUS(wstatus);
}

static inline bool flag(char **p, const char *name)
{
    return std::strcmp(*p, name) == 0;
}

static inline char *nextArg(char **&p, const char *err)
{
    ++p;
    if(*p == nullptr)
        throw std::runtime_error(err);
    return *p;
}

static inline bool startsWith(char **p, const char *prefix)
{
    return std::strncmp(*p, prefix, std::strlen(prefix)) == 0;
}

struct TempFileGuard
{
    inline ~TempFileGuard()
    {
        if (tmpfile)
            unlink(tmpfile);
    }

    const char *tmpfile;
};

static int Elf2Mac(char *argv[])
{
    std::string realLdPath;
    if (const char *path = getenv("RETRO68_REAL_LD"); path && path[0] != '\0')
        realLdPath = path;
    else
        realLdPath = argv[0] + ".real"s;
    const char *outputFile = "a.out";
    const char *entryPoint = "_start";
    uint32_t stackSize = 0;
    bool elf2mac = false;
    bool flatoutput = false;
    bool segments = true;
    bool stripMacsbug = false;
    bool saveLdScript = false;
    bool palmos = std::strstr(argv[0], "palmos") != nullptr;
    bool verbose = false;
    char verbosity[16];

    SegmentMap segmentMap;

    std::vector<const char *> ldArgv;
    ldArgv.push_back(realLdPath.c_str());
    for(auto p = argv + 1; *p != nullptr; ++p)
    {
        if(flag(p, "--elf2mac-real-ld"))
            ldArgv[0] = nextArg(p, "--elf2mac-real-ld missing argument");
        else if(flag(p, "-o"))
            outputFile = nextArg(p, "-o missing argument");
        else if(startsWith(p, "-o"))
            outputFile = (*p) + 2;
        else if(flag(p, "-elf2mac") || flag(p, "--elf2mac"))
            elf2mac = true;
        else if(flag(p, "-e"))
            entryPoint = nextArg(p, "-e missing argument");
        else if(startsWith(p, "-e"))
            entryPoint = (*p) + 2;
        else if(flag(p, "--mac-flat"))
        {
            elf2mac = true;
            flatoutput = true;
            segments = false;
        }
        else if(flag(p, "--mac-single"))
        {
            elf2mac = true;
            flatoutput = false;
            segments = false;
        }
        else if(flag(p, "--mac-segments"))
        {
            elf2mac = true;
            segmentMap = SegmentMap(nextArg(p, "--mac-segments missing argument"));
        }
        else if(flag(p, "--mac-strip-macsbug"))
            stripMacsbug = true;
        else if(flag(p, "--mac-keep-ldscript"))
            saveLdScript = true;
        else if (flag(p, "--palmos"))
            palmos = true;
        else if (flag(p, "--stack"))
            stackSize = std::atoi(nextArg(p, "--stack missing argument"));
        else if(startsWith(p, "--verbose="))
        {
            // Take verbose=1 for Elf2Mac and pass higher numbers to ld
            uint8_t level = std::clamp(
                std::atoi(*p + sizeof("--verbose=") - 1), 0, UINT8_MAX);
            verbose = (level > 0);
            if (level > 1)
            {
                --level;
                std::sprintf(verbosity, "--verbose=%hhu", level);
                ldArgv.push_back(verbosity);
            }
        }
        else if (flag(p, "--verbose"))
            verbose = true;
        else
            ldArgv.push_back(*p);
    }

    if(flatoutput && segments)
        throw std::runtime_error("--mac-segments can't be used with --mac-flat");

#ifndef PALMOS
    if(palmos)
        throw std::runtime_error("Not compiled with Palm OS support");
#endif

    int result;
    if(elf2mac)
    {
        using namespace std::filesystem;
        auto tmpfile = (temp_directory_path() / "elf2macldXXXXXX").string();
        int fd = mkstemp(tmpfile.data());
        if(fd < 0)
            throw new std::runtime_error("can't create temp file: "s + strerror(errno));

        TempFileGuard guard { saveLdScript ? nullptr : tmpfile.c_str() };

        {
            std::ofstream out(tmpfile);
            if(segments)
                segmentMap.CreateLdScript(out, entryPoint, stripMacsbug, palmos);
            else
                CreateFlatLdScript(out, entryPoint, stripMacsbug);
        }

        if(saveLdScript)
            std::cerr << "Ld Script at: " << tmpfile << std::endl;

        std::string inputFile { outputFile + ".gdb"s };

        ldArgv.push_back("--no-check-sections");
        ldArgv.push_back("--no-warn-rwx-segments");
        ldArgv.push_back("-o");
        ldArgv.push_back(inputFile.c_str());
        ldArgv.push_back("-T");
        ldArgv.push_back(tmpfile.c_str());
        ldArgv.push_back(nullptr);

        if ((result = RealLD(ldArgv)) != 0)
            return result;

        Object theObject(inputFile, palmos, stackSize, verbose);

        if(flatoutput)
            theObject.FlatCode(outputFile);
        else if(segments)
            theObject.MultiSegmentApp(outputFile, segmentMap);
        else
            theObject.SingleSegmentApp(outputFile);
    }
    else
    {
        ldArgv.clear();
        for (auto p = argv; *p != nullptr; ++p)
            ldArgv.push_back(*p);
        ldArgv.push_back(nullptr);
        result = RealLD(ldArgv);
    }

    return result;
}

int main(int argc, char *argv[])
{
    try
    {
        if (argc < 1)
            throw std::runtime_error("missing argv[0]");

        return Elf2Mac(argv);
    }
    catch(const std::runtime_error &e)
    {
        std::cerr << "Error: " << e.what() << std::endl;
        return 1;
    }
}
