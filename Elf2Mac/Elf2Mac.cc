/*
     Copyright 2017 Wolfgang Thaller.

     This file is part of Retro68.

     Retro68 is free software: you can redistribute it and/or modify
     it under the terms of the GNU General Public License as published by
     the Free Software Foundation, either version 3 of the License, or
     (at your option) any later version.

     Retro68 is distributed in the hope that it will be useful,
     but WITHOUT ANY WARRANTY; without even the implied warranty of
     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     GNU General Public License for more details.

     You should have received a copy of the GNU General Public License
     along with Retro68.  If not, see <http://www.gnu.org/licenses/>.
*/

/**
 * Elf2Mac converts a normal elf-m68k executable to a Mac or Palm OS resource
 * file. It can be used either as a wrapper around binutils ld or as a
 * standalone utility. It works by generating a linker script for GNU ld, then
 * invoking ld, then performing post-processing on the intermediate elf-m68k
 * binary generated by ld and writing the processed data to the final output
 * resource file.
 *
 * The linker script is responsible for:
 *
 * • Splitting the `.text` section into multiple code sections according to the
 *   user-provided segment map (see SegmentMap);
 * • Merging ELF code and data sections into fewer sections suitable for
 *   resource files;
 * • Adding symbols for the libretro runtime to do relocation;
 * • Fixing relocation offsets by setting section VMAs and inserting required
 *   section headers that will be filled in later by Elf2Mac;
 * • Inserting the entrypoint trampoline for the code 1 resource.
 *
 * Elf2Mac is responsible for:
 *
 * • Transforming ELF relocations to libretro/Palm OS format;
 * • Replacing cross-section function calls with calls to the jump table to
 *   support on-demand code loading on Mac OS;
 * • Building the jump table and writing it to the appropriate place;
 * • Compressing section data (for Palm OS);
 * • Filling in code resource headers.
 */

#include "Object.h"
#include "SegmentMap.h"

#include <cstring>
#include <filesystem>
#include <fstream>
#include <iostream>
#include <string>
#include <system_error>
#include <vector>

#include <unistd.h>
#include <sys/types.h>
#include <sys/wait.h>

using namespace std::literals::string_literals;

static int RealLD(const std::string &realLdPath, const std::vector<std::string> &args)
{
    std::vector<const char *> argv;
    argv.reserve(args.size() + 2);
    argv.push_back(realLdPath.c_str());
    for(const auto &s : args)
        argv.push_back(s.c_str());
    argv.push_back(nullptr);

    pid_t pid = fork();
    if(pid < 0)
    {
        std::cerr << "unable to fork: " << strerror(errno) << std::endl;
        return 1;
    }
    else if(pid == 0)
    {
        execvp(argv[0], const_cast<char* const *> (argv.data()));
        std::cerr << "exec failed: " << strerror(errno) << std::endl;
        return 1;
    }

    int wstatus;
    int result = 0;
    do
    {
        result = waitpid(pid, &wstatus, 0);
    } while(result == -1 && errno == EINTR);

    if(WIFEXITED(wstatus))
        return WEXITSTATUS(wstatus);

    std::cerr << "ld process did not exit properly" << std::endl;
    return 1;
}

static inline bool flag(char **p, const char *name)
{
    return std::strcmp(*p, name) == 0;
}

static inline char *nextArg(char **&p, const char *err)
{
    ++p;
    if(*p == nullptr)
    {
        std::cerr << err << std::endl;
        std::exit(1);
    }
    return *p;
}

static inline bool startsWith(char **p, const char *prefix)
{
    return std::strncmp(*p, prefix, std::strlen(prefix)) == 0;
}

struct TempFileGuard
{
    inline ~TempFileGuard()
    {
        if (tmpfile)
            unlink(tmpfile);
    }

    const char *tmpfile;
};

int main(int, char *argv[])
{
    std::string realLdPath;
    if (const char *path = getenv("RETRO68_REAL_LD"); path && path[0] != '\0')
        realLdPath = path;
    else
        realLdPath = argv[0] + ".real"s;
    const char *outputFile = "a.out";
    const char *entryPoint = "_start";
    uint32_t stackSize = 4096;
    bool elf2mac = false;
    bool flatoutput = false;
    bool segments = true;
    bool stripMacsbug = false;
    bool saveLdScript = false;
    bool palmos = std::strstr(argv[0], "palmos") != nullptr;

    SegmentMap segmentMap;

    std::vector<std::string> ldArgs;
    for(auto p = argv + 1; *p != nullptr; ++p)
    {
        if(flag(p, "--elf2mac-real-ld"))
            realLdPath = nextArg(p, "--elf2mac-real-ld missing argument");
        else if(flag(p, "-o"))
            outputFile = nextArg(p, "-o missing argument");
        else if(startsWith(p, "-o"))
            outputFile = (*p) + 2;
        else if(flag(p, "-elf2mac") || flag(p, "--elf2mac"))
            elf2mac = true;
        else if(flag(p, "-e"))
            entryPoint = nextArg(p, "-e missing argument");
        else if(startsWith(p, "-e"))
            entryPoint = (*p) + 2;
        else if(flag(p, "--mac-flat"))
        {
            elf2mac = true;
            flatoutput = true;
            segments = false;
        }
        else if(flag(p, "--mac-single"))
        {
            elf2mac = true;
            flatoutput = false;
            segments = false;
        }
        else if(flag(p, "--mac-segments"))
        {
            elf2mac = true;
            segmentMap = SegmentMap(nextArg(p, "--mac-segments missing argument"));
        }
        else if(flag(p, "--mac-strip-macsbug"))
            stripMacsbug = true;
        else if(flag(p, "--mac-keep-ldscript"))
            saveLdScript = true;
        else if (flag(p, "--palmos"))
            palmos = true;
        else if (flag(p, "--stack"))
            stackSize = std::atoi(nextArg(p, "--stack missing argument"));
        else
            ldArgs.push_back(*p);
    }

    if(flatoutput && segments)
    {
        std::cerr << "--mac-segments can't be used with --mac-flat" << std::endl;
        return 1;
    }

#ifndef PALMOS
    if(palmos)
    {
        std::cerr << "Not compiled with Palm OS support" << std::endl;
        return 1;
    }
#endif

    int result;
    if(elf2mac)
    {
        using namespace std::filesystem;
        auto tmpfile = (temp_directory_path() / "elf2macldXXXXXX").string();
        int fd = mkstemp(tmpfile.data());
        if(fd < 0)
        {
            std::cerr
                << "can't create temp file: "s + strerror(errno)
                << std::endl;
            return 1;
        }

        TempFileGuard guard { saveLdScript ? nullptr : tmpfile.c_str() };

        {
            std::ofstream out(tmpfile);
            if(segments)
                segmentMap.CreateLdScript(out, entryPoint, stripMacsbug, palmos);
            else
                CreateFlatLdScript(out, entryPoint, stripMacsbug);
        }

        if(saveLdScript)
            std::cerr << "Ld Script at: " << tmpfile << std::endl;

        std::string inputFile { outputFile + ".gdb"s };

        ldArgs.push_back("--no-warn-rwx-segments");
        ldArgs.push_back("-o");
        ldArgs.push_back(inputFile);
        ldArgs.push_back("-T");
        ldArgs.push_back(tmpfile);

        if ((result = RealLD(realLdPath, ldArgs)) != 0)
            return result;

        Object theObject(inputFile, palmos, stackSize);

        if(flatoutput)
            theObject.FlatCode(outputFile);
        else if(segments)
            theObject.MultiSegmentApp(outputFile, segmentMap);
        else
            theObject.SingleSegmentApp(outputFile);
    }
    else
    {
        for (auto p = argv + 1; *p != nullptr; ++p)
            ldArgs.push_back(*p);

        result = RealLD(realLdPath, ldArgs);
    }

    return result;
}
